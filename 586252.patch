diff --git a/neutron/agent/rpc.py b/neutron/agent/rpc.py
index 3534abd3c6..67f3ed4461 100644
--- a/neutron/agent/rpc.py
+++ b/neutron/agent/rpc.py
@@ -112,6 +112,8 @@ class PluginApi(object):
         1.4 - tunnel_sync rpc signature upgrade to obtain 'host'
         1.5 - Support update_device_list and
               get_devices_details_list_and_failed_devices
+        1.6 - Support get_network_details
+        1.7 - Support get_ports_by_vnic_type_and_host
     '''
 
     def __init__(self, topic):
@@ -187,6 +189,11 @@ class PluginApi(object):
         return cctxt.call(context, 'tunnel_sync', tunnel_ip=tunnel_ip,
                           tunnel_type=tunnel_type, host=host)
 
+    def get_ports_by_vnic_type_and_host(self, context, vnic_type, host):
+        cctxt = self.client.prepare(version='1.7')
+        return cctxt.call(context, 'get_ports_by_vnic_type_and_host',
+                          vnic_type=vnic_type, host=host)
+
 
 def create_cache_for_l2_agent():
     """Create a push-notifications cache for L2 agent related resources."""
@@ -338,6 +345,7 @@ class CacheBackedPluginApi(PluginApi):
                                    dialect=netaddr.mac_unix_expanded))
         entry = {
             'device': device,
+            'device_id': port_obj.device_id,
             'network_id': port_obj.network_id,
             'port_id': port_obj.id,
             'mac_address': mac_addr,
@@ -357,6 +365,8 @@ class CacheBackedPluginApi(PluginApi):
             'qos_policy_id': port_obj.qos_policy_id,
             'network_qos_policy_id': net_qos_policy_id,
             'profile': binding.profile,
+            'vif_type': binding.vif_type,
+            'vnic_type': binding.vnic_type,
             'security_groups': list(port_obj.security_group_ids)
         }
         LOG.debug("Returning: %s", entry)
diff --git a/neutron/conf/plugins/ml2/drivers/ovs_conf.py b/neutron/conf/plugins/ml2/drivers/ovs_conf.py
index 199e4e2675..6c5582e255 100644
--- a/neutron/conf/plugins/ml2/drivers/ovs_conf.py
+++ b/neutron/conf/plugins/ml2/drivers/ovs_conf.py
@@ -175,7 +175,9 @@ agent_opts = [
                        "outgoing IP packet carrying GRE/VXLAN tunnel.")),
     cfg.StrOpt('agent_type', default=n_const.AGENT_TYPE_OVS,
                deprecated_for_removal=True,
-               help=_("Selects the Agent Type reported"))
+               help=_("Selects the Agent Type reported.")),
+    cfg.BoolOpt('baremetal_smartnic', default=False,
+                help=_("Enable the agent to process Smart NIC ports.")),
 ]
 
 
diff --git a/neutron/objects/ports.py b/neutron/objects/ports.py
index 6feaada32a..39ef8093d3 100644
--- a/neutron/objects/ports.py
+++ b/neutron/objects/ports.py
@@ -592,3 +592,13 @@ class Port(base.NeutronDbObject):
             ml2_models.PortBinding.vif_type == binding_type,
             ml2_models.PortBinding.host == host)
         return [cls._load_object(context, db_obj) for db_obj in query.all()]
+
+    @classmethod
+    def get_ports_by_vnic_type_and_host(
+            cls, context, vnic_type, host):
+        query = context.session.query(models_v2.Port).join(
+            ml2_models.PortBinding)
+        query = query.filter(
+            ml2_models.PortBinding.vnic_type == vnic_type,
+            ml2_models.PortBinding.host == host)
+        return [cls._load_object(context, db_obj) for db_obj in query.all()]
diff --git a/neutron/plugins/ml2/drivers/mech_agent.py b/neutron/plugins/ml2/drivers/mech_agent.py
index 5b41cdfea7..f24ec9d85a 100644
--- a/neutron/plugins/ml2/drivers/mech_agent.py
+++ b/neutron/plugins/ml2/drivers/mech_agent.py
@@ -105,6 +105,11 @@ class AgentMechanismDriverBase(api.MechanismDriver):
         for agent in agents:
             LOG.debug("Checking agent: %s", agent)
             if agent['alive']:
+                if (vnic_type == portbindings.VNIC_SMARTNIC and not
+                        agent['configurations'].get('baremetal_smartnic')):
+                    LOG.debug('Agent on host %s can not bind SmartNIC '
+                              'port %s', agent['host'], context.current['id'])
+                    continue
                 for segment in context.segments_to_bind:
                     if self.try_to_bind_segment_for_agent(context, segment,
                                                           agent):
diff --git a/neutron/plugins/ml2/drivers/openvswitch/agent/ovs_neutron_agent.py b/neutron/plugins/ml2/drivers/openvswitch/agent/ovs_neutron_agent.py
index 29ffb316ef..5cda1c057a 100644
--- a/neutron/plugins/ml2/drivers/openvswitch/agent/ovs_neutron_agent.py
+++ b/neutron/plugins/ml2/drivers/openvswitch/agent/ovs_neutron_agent.py
@@ -33,6 +33,10 @@ from neutron_lib import context
 from neutron_lib.placement import utils as place_utils
 from neutron_lib.plugins import utils as plugin_utils
 from neutron_lib.utils import helpers
+import os_vif
+from os_vif.objects import instance_info as vif_instance_object
+from os_vif.objects import network as vif_network_object
+from os_vif.objects import vif as vif_obj
 from oslo_config import cfg
 from oslo_log import log as logging
 import oslo_messaging
@@ -128,7 +132,8 @@ class OVSNeutronAgent(l2population_rpc.L2populationRpcCallBackTunnelMixin,
     #   1.3 Added param devices_to_update to security_groups_provider_updated
     #   1.4 Added support for network_update
     #   1.5 Added binding_activate and binding_deactivate
-    target = oslo_messaging.Target(version='1.5')
+    #   1.7 Add support for smartnic ports
+    target = oslo_messaging.Target(version='1.7')
 
     def __init__(self, bridge_classes, ext_manager, conf=None):
         '''Constructor.
@@ -182,6 +187,8 @@ class OVSNeutronAgent(l2population_rpc.L2populationRpcCallBackTunnelMixin,
         self.deactivated_bindings = set()
         # Stores the port IDs whose binding has been activated
         self.activated_bindings = set()
+        # Stores smartnic ports update/remove
+        self.updated_smartnic_ports = list()
 
         self.network_ports = collections.defaultdict(set)
         # keeps association between ports and ofports to detect ofport change
@@ -313,7 +320,9 @@ class OVSNeutronAgent(l2population_rpc.L2populationRpcCallBackTunnelMixin,
                                'ovs_capabilities': self.ovs.capabilities,
                                'vhostuser_socket_dir':
                                ovs_conf.vhostuser_socket_dir,
-                               portbindings.OVS_HYBRID_PLUG: hybrid_plug},
+                               portbindings.OVS_HYBRID_PLUG: hybrid_plug,
+                               'baremetal_smartnic':
+                               self.conf.AGENT.baremetal_smartnic},
             'resource_versions': resources.LOCAL_RESOURCE_VERSIONS,
             'agent_type': agent_conf.agent_type,
             'start_flag': True}
@@ -330,6 +339,9 @@ class OVSNeutronAgent(l2population_rpc.L2populationRpcCallBackTunnelMixin,
         self.catch_sigterm = False
         self.catch_sighup = False
 
+        if self.conf.AGENT.baremetal_smartnic:
+            os_vif.initialize()
+
         # The initialization is complete; we can start receiving messages
         self.connection.consume_in_threads()
 
@@ -462,6 +474,79 @@ class OVSNeutronAgent(l2population_rpc.L2populationRpcCallBackTunnelMixin,
             # notification.
             self.updated_ports.add(port['id'])
 
+        if not self.conf.AGENT.baremetal_smartnic:
+            return
+        # In case of smart-nic port, add smart-nic representor port to
+        # the integration bridge.
+        port_data = (self.plugin_rpc.remote_resource_cache
+                     .get_resource_by_id(resources.PORT, port['id']))
+        if not port_data:
+            LOG.warning('Failed to get port details, port id: %s', port['id'])
+            return
+        for port_binding in port_data.get('bindings', []):
+            if port_binding['vnic_type'] == portbindings.VNIC_SMARTNIC:
+                if port_binding['host'] == self.conf.host:
+                    self._add_port_to_updated_smartnic_ports(port_data,
+                                                             port_binding)
+                else:
+                    # The port doesn't belong to this Smart NIC,
+                    # the reason for this could be multi Smart NIC
+                    # setup.
+                    LOG.info("Smart NIC port %(port_id)s does not belong "
+                             "to host %(host)s",
+                             {'port_id': port['id'],
+                              'host': self.conf.host})
+
+    def treat_smartnic_port(self, smartnic_port_data):
+        mac = smartnic_port_data['mac']
+        vm_uuid = smartnic_port_data['vm_uuid']
+        rep_port = smartnic_port_data['iface_name']
+        iface_id = smartnic_port_data['iface_id']
+        vif_type = smartnic_port_data['vif_type']
+
+        instance_info = vif_instance_object.InstanceInfo(uuid=vm_uuid)
+        vif = self._get_vif_object(iface_id, rep_port, mac)
+        try:
+            if vif_type == portbindings.VIF_TYPE_OVS:
+                os_vif.plug(vif, instance_info)
+
+            elif vif_type == portbindings.VIF_TYPE_UNBOUND:
+                os_vif.unplug(vif, instance_info)
+
+            else:
+                LOG.error("Unexpected vif_type:%(vif_type)s for "
+                          "%(vnic_type)s port:%(port_id)s",
+                          {'vnic_type': portbindings.VNIC_SMARTNIC,
+                           'vif_type': vif_type,
+                           'port_id': iface_id})
+
+        except Exception as e:
+            LOG.error("Failed to treat %(vnic_type)s port:%(port_id)s , "
+                      "error:%(error)s",
+                      {'vnic_type': portbindings.VNIC_SMARTNIC,
+                       'port_id': iface_id,
+                       'error': e})
+
+    def _get_vif_object(self, iface_id, rep_port, mac):
+        network = vif_network_object.Network(
+            bridge=self.conf.OVS.integration_bridge)
+        port_profile = vif_obj.VIFPortProfileOpenVSwitch(
+            interface_id=iface_id, create_port=True)
+        return vif_obj.VIFOpenVSwitch(
+            vif_name=rep_port, plugin='ovs', port_profile=port_profile,
+            network=network, address=str(mac))
+
+    def _add_port_to_updated_smartnic_ports(self, port_data, port_binding):
+        local_link = port_binding['profile']['local_link_information']
+        if local_link:
+            iface_name = local_link[0]['port_id']
+            self.updated_smartnic_ports.append({
+                'mac': port_data['mac_address'],
+                'vm_uuid': port_data['device_id'],
+                'iface_name': iface_name,
+                'iface_id': port_data['id'],
+                'vif_type': port_binding['vif_type']})
+
     def port_delete(self, context, **kwargs):
         port_id = kwargs.get('port_id')
         self.deleted_ports.add(port_id)
@@ -521,6 +606,17 @@ class OVSNeutronAgent(l2population_rpc.L2populationRpcCallBackTunnelMixin,
         # more secure
         self.sg_agent.remove_devices_filter(deleted_ports)
 
+    def process_smartnic_ports(self):
+        smartnic_ports = self.plugin_rpc.get_ports_by_vnic_type_and_host(
+            self.context, portbindings.VNIC_SMARTNIC, self.conf.host)
+        ports = self.int_br.get_vif_port_set()
+        for smartnic_port in smartnic_ports:
+            if smartnic_port['id'] not in ports:
+                self._add_port_to_updated_smartnic_ports(
+                    smartnic_port,
+                    {'profile': smartnic_port['binding:profile'],
+                     'vif_type': smartnic_port['binding:vif_type']})
+
     def process_deactivated_bindings(self, port_info):
         # don't try to deactivate bindings for removed ports since they are
         # already gone
@@ -1965,6 +2061,7 @@ class OVSNeutronAgent(l2population_rpc.L2populationRpcCallBackTunnelMixin,
                 self.deleted_ports or
                 self.deactivated_bindings or
                 self.activated_bindings or
+                self.updated_smartnic_ports or
                 self.sg_agent.firewall_refresh_needed())
 
     def _port_info_has_changes(self, port_info):
@@ -2243,6 +2340,16 @@ class OVSNeutronAgent(l2population_rpc.L2populationRpcCallBackTunnelMixin,
                               "starting polling. Elapsed:%(elapsed).3f",
                               {'iter_num': self.iter_num,
                                'elapsed': time.time() - start})
+
+                    if self.conf.AGENT.baremetal_smartnic:
+                        if sync:
+                            self.process_smartnic_ports()
+                        updated_smartnic_ports_copy = (
+                            self.updated_smartnic_ports)
+                        self.updated_smartnic_ports = list()
+                        for port_data in updated_smartnic_ports_copy:
+                            self.treat_smartnic_port(port_data)
+
                     # Save updated ports dict to perform rollback in
                     # case resync would be needed, and then clear
                     # self.updated_ports. As the greenthread should not yield
diff --git a/neutron/plugins/ml2/drivers/openvswitch/mech_driver/mech_openvswitch.py b/neutron/plugins/ml2/drivers/openvswitch/mech_driver/mech_openvswitch.py
index 214259d519..a2ed211104 100644
--- a/neutron/plugins/ml2/drivers/openvswitch/mech_driver/mech_openvswitch.py
+++ b/neutron/plugins/ml2/drivers/openvswitch/mech_driver/mech_openvswitch.py
@@ -76,7 +76,9 @@ class OpenvswitchMechanismDriver(mech_agent.SimpleAgentMechanismDriverBase):
         # SimpleAgentMechanismDriverBase. By that e blacklisting and validation
         # of the vnic_types would be available for all mechanism drivers.
         self.supported_vnic_types = self.blacklist_supported_vnic_types(
-            vnic_types=[portbindings.VNIC_NORMAL, portbindings.VNIC_DIRECT],
+            vnic_types=[portbindings.VNIC_NORMAL,
+                        portbindings.VNIC_DIRECT,
+                        portbindings.VNIC_SMARTNIC],
             blacklist=cfg.CONF.OVS_DRIVER.vnic_type_blacklist
         )
         LOG.info("%s's supported_vnic_types: %s",
diff --git a/neutron/plugins/ml2/plugin.py b/neutron/plugins/ml2/plugin.py
index 99deb93142..a7a3067561 100644
--- a/neutron/plugins/ml2/plugin.py
+++ b/neutron/plugins/ml2/plugin.py
@@ -2537,3 +2537,11 @@ class Ml2Plugin(db_base_plugin_v2.NeutronDbPluginV2,
         db.clear_binding_levels(context,
                                 port_id=port_id,
                                 host=host)
+
+    @db_api.retry_if_session_inactive()
+    def get_ports_by_vnic_type_and_host(self, context, **kwargs):
+        host = kwargs['host']
+        vnic_type = kwargs['vnic_type']
+        ports = ports_obj.Port.get_ports_by_vnic_type_and_host(
+            context, vnic_type, host)
+        return [self._make_port_dict(port.db_obj) for port in ports]
diff --git a/neutron/plugins/ml2/rpc.py b/neutron/plugins/ml2/rpc.py
index ddcc87dc7a..52e6c3d60a 100644
--- a/neutron/plugins/ml2/rpc.py
+++ b/neutron/plugins/ml2/rpc.py
@@ -53,7 +53,9 @@ class RpcCallbacks(type_tunnel.TunnelRpcCallbackMixin):
     #   1.4 tunnel_sync rpc signature upgrade to obtain 'host'
     #   1.5 Support update_device_list and
     #       get_devices_details_list_and_failed_devices
-    target = oslo_messaging.Target(version='1.5')
+    #   1.6 Support get_network_details
+    #   1.7 Support get_ports_by_vnic_type_and_host
+    target = oslo_messaging.Target(version='1.7')
 
     def __init__(self, notifier, type_manager):
         self.setup_tunnel_callback_mixin(notifier, type_manager)
@@ -393,6 +395,11 @@ class RpcCallbacks(type_tunnel.TunnelRpcCallbackMixin):
                 'devices_down': devices_down,
                 'failed_devices_down': failed_devices_down}
 
+    def get_ports_by_vnic_type_and_host(self, rpc_context, vnic_type, host):
+        plugin = directory.get_plugin()
+        return plugin.get_ports_by_vnic_type_and_host(
+            rpc_context, vnic_type=vnic_type, host=host)
+
 
 class AgentNotifierApi(dvr_rpc.DVRAgentRpcApiMixin,
                        sg_rpc.SecurityGroupAgentRpcApiMixin,
